#include "Spawner.h"
#include <glad/glad.h>
#include <stdexcept>
#include <cmath>
#include "util.h"

//i think there is a memory leak here

Spawner::Spawner(Shader* shader,Shader* ballShader,float cx, float cy,float
    baseFrequency,float scale) {
  this->radius = 0.02f;
  this->sides = 50;
  this->shader = shader;
  this->ballShader = ballShader;
  this->cx = cx;
  this->cy = cy;
  this->baseFrequency = baseFrequency;
  this->scale = scale;
  this->lastQuantumSpawn = 0;

  //TODO check if vertices are in NDC
  if ( cx < -1 || cy > 1 ) {
    throw std::invalid_argument(" cx & cy , must be in the range [-1,1]");
  }
 
  int vertex_total = 0; this->vertices = keville::util::generate_regular_polygon_hull_vertices(this->sides,this->radius,vertex_total);

  //generate buffers
  glGenVertexArrays(1, &vao);
  glGenBuffers(1,&vbo);
  //assemble vertex array
  glBindBuffer(GL_ARRAY_BUFFER,vbo);
  glBindVertexArray(vao);
  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
  glEnableVertexAttribArray(0); 
  glBindVertexArray(0);
 
  //initialize vertex buffer
  glBindBuffer(GL_ARRAY_BUFFER, vbo);
  glBufferData(GL_ARRAY_BUFFER, sizeof(float) * 3 * 2 * this->sides, vertices, GL_STATIC_DRAW);

}

void Spawner::draw() {
  shader->use();

  int ColorLoc = glGetUniformLocation(shader->ID, "Color"); 
  glUniform3f(ColorLoc,1.f,1.f,1.f);
  int WorldPositionLoc = glGetUniformLocation(shader->ID, "WorldPosition"); 
  glUniform2f(WorldPositionLoc,this->cx,this->cy);

  glLineWidth(2.0f);
  glBindBuffer(GL_ARRAY_BUFFER,vbo);
  glBindVertexArray(vao); 
  glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(float) * 3 * 2 * this->sides, vertices);
  
  glDrawArrays(GL_LINES, 0, 3*this->sides);
}




Ball* Spawner::spawn(float currentTime) {

  float wavelength = (1.f / this->baseFrequency ); //is this a safe cast?
  float quantum = wavelength/this->scale;
  float epsilon = 0.01f;  //10ms

  flaot now = currentTime / quantum;
  float leftQuantum = floor( currentTime / quantum );
  float rightQuantum = ceil( currentTime / quantum );

  //are we within the left quantum and it isn't the last quantum?
  if ( leftQuantum != lastQuantumSpawn && 


  return nullptr;

  /*
  if ( currentTime > lastSpawn + (1/frequency) ) {
    lastSpawn = currentTime;
    return new Ball(this->ballShader,this->sides,this->cx,this->cy);
  }
  return nullptr;
  */
}

bool Spawner::IsHovering(float ndcx,float ndcy) {
  //we "move" the circle that represents a spawner to the origin
  //and the ndc coordintes to see if they are within the circle 
  float local_x = ndcx - this->cx;
  float local_y = ndcy - this->cy;
  float local_r = sqrt(pow(local_x,2) + pow(local_y,2));
  float tolerance = 1.2f; //enlarge the detection radius slightly more than the actualy shape
  return ( local_r < (this->radius*tolerance));
}

void Spawner::move(float x,float y) {
  this->cx += x;
  this->cy += y;
}

void Spawner::position(float x,float y) {
  this->cx = x;
  this->cy = y;
}











